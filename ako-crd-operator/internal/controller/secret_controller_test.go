/*
Copyright 2019-2025 VMware, Inc.
All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"errors"
	"testing"

	"github.com/vmware/alb-sdk/go/clients"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/internal/event"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/ako-crd-operator/internal/session"
	"github.com/vmware/load-balancer-and-ingress-services-for-kubernetes/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	kubefake "k8s.io/client-go/kubernetes/fake"
	"k8s.io/client-go/tools/record"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// @AI-Generated
// [Generated by Cursor claude-4-sonnet]

// MockReconciler implements AviClientReconciler for testing
type MockReconciler struct {
	name        string
	updateError error
	updateCalls int
}

func (m *MockReconciler) UpdateAviClient(client session.AviClientInterface) error {
	m.updateCalls++
	return m.updateError
}

func (m *MockReconciler) GetReconcilerName() string {
	return m.name
}

func (m *MockReconciler) SetUpdateError(err error) {
	m.updateError = err
}

func (m *MockReconciler) GetUpdateCalls() int {
	return m.updateCalls
}

// Helper function to create a test secret
func createTestSecret(name, namespace string, data map[string][]byte) *corev1.Secret {
	return &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
		Data: data,
	}
}

// Helper function to create SecretReconciler for testing
func createTestSecretReconciler(objects ...client.Object) *SecretReconciler {
	scheme := runtime.NewScheme()
	_ = corev1.AddToScheme(scheme)

	fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithObjects(objects...).Build()
	kubeClient := kubefake.NewSimpleClientset()
	eventRecorder := utils.NewEventRecorder("ako-crd-operator", kubeClient, false)
	eventManager := event.NewEventManager(eventRecorder, &corev1.Pod{})

	// Initialize singleton session for testing
	session.ResetSessionInstance() // Reset any previous singleton
	session.InitializeSessionInstance(kubeClient, eventManager)

	reconciler := NewSecretReconciler(
		fakeClient,
		scheme,
		"test-cluster",
	)
	reconciler.EventRecorder = &record.FakeRecorder{}

	return reconciler
}

func TestNewSecretReconciler(t *testing.T) {
	scheme := runtime.NewScheme()
	fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	kubeClient := kubefake.NewSimpleClientset()
	eventRecorder := utils.NewEventRecorder("ako-crd-operator", kubeClient, false)
	eventManager := event.NewEventManager(eventRecorder, &corev1.Pod{})

	// Initialize singleton session for testing
	session.ResetSessionInstance()
	session.InitializeSessionInstance(kubeClient, eventManager)

	reconciler := NewSecretReconciler(
		fakeClient,
		scheme,
		"test-cluster",
	)

	if reconciler.ClusterName != "test-cluster" {
		t.Errorf("Expected cluster name 'test-cluster', got %s", reconciler.ClusterName)
	}
	if reconciler.reconcilers == nil {
		t.Error("Expected reconcilers slice to be initialized")
	}
	if len(reconciler.reconcilers) != 0 {
		t.Errorf("Expected 0 reconcilers, got %d", len(reconciler.reconcilers))
	}
}

func TestRegisterReconciler(t *testing.T) {
	reconciler := createTestSecretReconciler()

	mockReconciler1 := &MockReconciler{name: "test-reconciler-1"}
	mockReconciler2 := &MockReconciler{name: "test-reconciler-2"}

	// Test successful registration
	err := reconciler.RegisterReconciler(mockReconciler1)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if len(reconciler.reconcilers) != 1 {
		t.Errorf("Expected 1 reconciler, got %d", len(reconciler.reconcilers))
	}

	// Test registering another reconciler
	err = reconciler.RegisterReconciler(mockReconciler2)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if len(reconciler.reconcilers) != 2 {
		t.Errorf("Expected 2 reconcilers, got %d", len(reconciler.reconcilers))
	}

	// Test duplicate registration
	err = reconciler.RegisterReconciler(mockReconciler1)
	if err == nil {
		t.Error("Expected error for duplicate registration, got nil")
	}
	if len(reconciler.reconcilers) != 2 {
		t.Errorf("Expected 2 reconcilers after duplicate registration, got %d", len(reconciler.reconcilers))
	}
}

func TestGetRegisteredReconcilers(t *testing.T) {
	reconciler := createTestSecretReconciler()

	mockReconciler1 := &MockReconciler{name: "test-reconciler-1"}
	mockReconciler2 := &MockReconciler{name: "test-reconciler-2"}

	// Initially empty
	names := reconciler.GetRegisteredReconcilers()
	if len(names) != 0 {
		t.Errorf("Expected 0 registered reconcilers initially, got %d", len(names))
	}

	// Register reconcilers
	_ = reconciler.RegisterReconciler(mockReconciler1)
	_ = reconciler.RegisterReconciler(mockReconciler2)

	names = reconciler.GetRegisteredReconcilers()
	if len(names) != 2 {
		t.Errorf("Expected 2 registered reconcilers, got %d", len(names))
	}

	// Check names are present
	found1, found2 := false, false
	for _, name := range names {
		if name == "test-reconciler-1" {
			found1 = true
		}
		if name == "test-reconciler-2" {
			found2 = true
		}
	}
	if !found1 || !found2 {
		t.Errorf("Expected to find both reconciler names, found1=%v, found2=%v", found1, found2)
	}
}

func TestValidateSecretData(t *testing.T) {
	reconciler := createTestSecretReconciler()

	tests := []struct {
		name      string
		secret    *corev1.Secret
		expectErr bool
	}{
		{
			name: "valid secret with password",
			secret: createTestSecret("test", "test", map[string][]byte{
				"username": []byte("admin"),
				"password": []byte("password123"),
			}),
			expectErr: false,
		},
		{
			name: "valid secret with authtoken",
			secret: createTestSecret("test", "test", map[string][]byte{
				"username":  []byte("admin"),
				"authtoken": []byte("token123"),
			}),
			expectErr: false,
		},
		{
			name: "valid secret with both password and authtoken",
			secret: createTestSecret("test", "test", map[string][]byte{
				"username":  []byte("admin"),
				"password":  []byte("password123"),
				"authtoken": []byte("token123"),
			}),
			expectErr: false,
		},
		{
			name: "missing username",
			secret: createTestSecret("test", "test", map[string][]byte{
				"password": []byte("password123"),
			}),
			expectErr: true,
		},
		{
			name: "missing password and authtoken",
			secret: createTestSecret("test", "test", map[string][]byte{
				"username": []byte("admin"),
			}),
			expectErr: true,
		},
		{
			name: "empty password and authtoken",
			secret: createTestSecret("test", "test", map[string][]byte{
				"username":  []byte("admin"),
				"password":  []byte(""),
				"authtoken": []byte(""),
			}),
			expectErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := reconciler.validateSecretData(tt.secret)
			if tt.expectErr && err == nil {
				t.Error("Expected error, got nil")
			}
			if !tt.expectErr && err != nil {
				t.Errorf("Expected no error, got %v", err)
			}
		})
	}
}

func TestReconcile_IgnoreNonAviSecret(t *testing.T) {
	reconciler := createTestSecretReconciler()

	// Test with non-avi-secret
	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      "other-secret",
			Namespace: utils.GetAKONamespace(),
		},
	}

	result, err := reconciler.Reconcile(context.Background(), req)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if result != (ctrl.Result{}) {
		t.Errorf("Expected empty result, got %v", result)
	}
}

func TestReconcile_IgnoreWrongNamespace(t *testing.T) {
	reconciler := createTestSecretReconciler()

	// Test with avi-secret in wrong namespace
	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      AviSecretName,
			Namespace: "wrong-namespace",
		},
	}

	result, err := reconciler.Reconcile(context.Background(), req)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if result != (ctrl.Result{}) {
		t.Errorf("Expected empty result, got %v", result)
	}
}

func TestReconcile_SecretNotFound(t *testing.T) {
	reconciler := createTestSecretReconciler()

	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      AviSecretName,
			Namespace: utils.GetAKONamespace(),
		},
	}

	result, err := reconciler.Reconcile(context.Background(), req)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}
	if result != (ctrl.Result{}) {
		t.Errorf("Expected empty result, got %v", result)
	}
}

func TestReconcile_InvalidSecretData(t *testing.T) {
	// Create invalid secret (missing username)
	invalidSecret := createTestSecret(AviSecretName, utils.GetAKONamespace(), map[string][]byte{
		"password": []byte("password123"),
	})

	reconciler := createTestSecretReconciler(invalidSecret)

	req := reconcile.Request{
		NamespacedName: types.NamespacedName{
			Name:      AviSecretName,
			Namespace: utils.GetAKONamespace(),
		},
	}

	result, err := reconciler.Reconcile(context.Background(), req)
	if err == nil {
		t.Error("Expected error for invalid secret data, got nil")
	}
	if result.RequeueAfter != DefaultRequeueDelay {
		t.Errorf("Expected requeue after %v, got %v", DefaultRequeueDelay, result.RequeueAfter)
	}
}

func TestGetReconcilerName(t *testing.T) {
	reconciler := createTestSecretReconciler()
	if reconciler.GetReconcilerName() != SecretControllerName {
		t.Errorf("Expected %s, got %s", SecretControllerName, reconciler.GetReconcilerName())
	}
}

func TestUpdateAviClient(t *testing.T) {
	reconciler := createTestSecretReconciler()

	// This should be a no-op for SecretReconciler
	err := reconciler.UpdateAviClient(nil)
	if err != nil {
		t.Errorf("Expected no error for no-op UpdateAviClient, got %v", err)
	}
}

func TestNotifyReconcilers_WithErrors(t *testing.T) {
	reconciler := createTestSecretReconciler()

	mockReconciler1 := &MockReconciler{name: "test-reconciler-1"}
	mockReconciler2 := &MockReconciler{name: "test-reconciler-2"}

	// First reconciler succeeds, second fails
	mockReconciler1.SetUpdateError(nil)
	mockReconciler2.SetUpdateError(errors.New("update failed"))

	_ = reconciler.RegisterReconciler(mockReconciler1)
	_ = reconciler.RegisterReconciler(mockReconciler2)

	// Create mock AVI client pool - we can't actually create real clients without AVI controller
	// This test focuses on the error handling logic rather than actual AVI integration
	aviClients := &utils.AviRestClientPool{
		AviClient: make([]*clients.AviClient, 3), // Mock with nil clients
	}

	err := reconciler.NotifyReconcilers(context.Background(), aviClients)
	if err == nil {
		t.Error("Expected error when reconciler fails, got nil")
	}

	// Check that both reconcilers were called
	if mockReconciler1.GetUpdateCalls() != 1 {
		t.Errorf("Expected reconciler1 to be called once, got %d", mockReconciler1.GetUpdateCalls())
	}
	if mockReconciler2.GetUpdateCalls() != 1 {
		t.Errorf("Expected reconciler2 to be called once, got %d", mockReconciler2.GetUpdateCalls())
	}
}
